#include "stdafx.h"

using namespace std;

static string dummy =
R"()";

namespace Puzzle03_2017_Types
{
	class spiral_iterator
	{
	public:
		using value_type = pair<int64_t, Point2>;
		using difference_type = ptrdiff_t;

		spiral_iterator()
		{
		}

		explicit spiral_iterator(const Point2& start)
			: Current({ 1, start })
		{
		}

		spiral_iterator(const spiral_iterator&) = default;

		const value_type& operator*() const
		{
			return Current;
		}

		const value_type* operator->() const
		{
			return &Current;
		}

		spiral_iterator& operator++()
		{
			Next();
			return *this;
		}

		spiral_iterator operator++(int)
		{
			spiral_iterator prev{ *this };
			Next();
			return prev;
		}

		inline bool operator==(const spiral_iterator& other) const
		{
			// Minimum support for comparing against end sentinel
			return Current == other.Current;
		}

	private:

		void Next()
		{
			// Move current point
			Current.first++;
			Current.second = Current.second + DirectionCycle[SpiralArmIndex % 4];

			// Turn corner to new arm if needed
			SpiralArmCount++;
			if (SpiralArmCount == SpiralArmLength)
			{
				SpiralArmIndex++;
				SpiralArmLength = (SpiralArmIndex / 2) + 1;
				SpiralArmCount = 0;
			}
		}

		// The square spiral is generated by moving:
		// Rx1 Ux1 Lx2 Dx2 Rx3 Ux3 Lx4 Dx4 ...
		// Cycling Right, Up, Left, Down at each turn
		// Moving with lengths before turns that increase in pairs:
		// 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, ...

		int64_t SpiralArmIndex = 0; // Where we are in the RULD cycle
		int64_t SpiralArmLength = 1; // The length of the currently active 'arm'
		int64_t SpiralArmCount = 0; // How far through the arm we are before the turn comes up

		pair<int64_t, Point2> Current{ -1, { numeric_limits<int64_t>::max(), numeric_limits<int64_t>::max() } };

		static vector<Point2> DirectionCycle;
	};

	vector<Point2> spiral_iterator::DirectionCycle{ Point2::Right(), Point2::Up(), Point2::Left(), Point2::Down() };

	inline bool operator!=(const spiral_iterator& a, const spiral_iterator& b)
	{
		return !(a == b);
	}

	static_assert(input_or_output_iterator<spiral_iterator>);

	class spiral_view : public ranges::view_interface<spiral_view>
	{
	public:
		spiral_iterator begin() const
		{
			return spiral_iterator{ Point2{ 0, 0 } };
		}

		spiral_iterator end() const
		{
			return {};
		}
	};

	spiral_view spiral()
	{
		return {};
	}
}

using namespace Puzzle03_2017_Types;

static Point2 SquareSpiralCoordinates(int64_t n)
{
	if (n == 1)
	{
		return { 0, 0 };
	}

	int64_t offsetN = n - 1;

	int64_t ringIndex = (static_cast<int64_t>(sqrt(offsetN)) + 1) / 2;
	int64_t ringBegin = ((ringIndex * 2) - 1) * ((ringIndex * 2) - 1);
	int64_t ringEnd = (((ringIndex + 1) * 2) - 1) * (((ringIndex + 1) * 2) - 1);
	int64_t ringOffset = offsetN - ringBegin;
	int64_t ringSize = ringEnd - ringBegin;

	int64_t ringQuadrant = (ringOffset * 4) / ringSize;

	int64_t quadrantSize = ringSize / 4;
	int64_t quadrantBegin = ringBegin + (ringQuadrant * quadrantSize);
	int64_t quadrantOffset = offsetN - quadrantBegin;

	switch (ringQuadrant)
	{
	case 0: return { ringIndex, ringIndex - 1 - quadrantOffset };
	case 1: return { ringIndex - 1 - quadrantOffset, -ringIndex };
	case 2: return { -ringIndex, -ringIndex + 1 + quadrantOffset };
	case 3: return { -ringIndex + 1 + quadrantOffset, ringIndex };
	}

	return { 0, 0 };
}

static void Puzzle03_A(const string &filename)
{
	(void)filename;
	ifstream input(filename);
	//istringstream input(dummy);

	assert(SquareSpiralCoordinates(27) == Point2( 3, 1 ));

	int64_t spiralIndex = atoll(ReadSingleLine(input).c_str());
	Point2 spiralCoordinate = SquareSpiralCoordinates(spiralIndex);

	int64_t answer = abs(spiralCoordinate.X) + abs(spiralCoordinate.Y);

	printf("[2017] Puzzle03_A: %" PRId64 "\n", answer);
}


static void Puzzle03_B(const string& filename)
{
	(void)filename;
	ifstream input(filename);
	//istringstream input(dummy);

	int64_t targetValue = atoll(ReadSingleLine(input).c_str());

	int64_t answer = 0;

	map<Point2, int64_t> spiralValues;
	for (const auto& p : spiral())
	{
		auto surroundingValues = Point2::CardinalAndDiagonalDirections()
			| views::transform([&](const Point2& dir)
				{
					return spiralValues[p.second + dir];
				});
		int64_t surroundingSum = accumulate(surroundingValues.begin(), surroundingValues.end(), 0ll);
		int64_t spiralValue = max(surroundingSum, 1ll);;
		spiralValues[p.second] = spiralValue;

		if (spiralValue > targetValue)
		{
			answer = spiralValue;
			break;
		}
	}

	printf("[2017] Puzzle03_B: %" PRId64 "\n", answer);
}

void Puzzle03_2017(const string& filename)
{
	Puzzle03_A(filename);
	Puzzle03_B(filename);
}
